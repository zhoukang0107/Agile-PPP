<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第三部分 薪水支付案例研究</title>
	</head>
		<h2>第十三章 COMMAND模式和ACTIVE OBJECT模式</h2>
		<div>
			<h3>简单的COMMAND</h3>
	<pre>
	程序13.1
	interface Command
		public void do();
	}
	</pre>
	       在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不
		   合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）<br />
	<pre>
	程序13.1
	interface Command
		public void do();
		public void undo();
	}
	</pre>
	        COMMAND模式增加了undo()方法。显而易见，如果Command派生类的do()方法可以记住它所执行的操作的细节，那么undo方法就可以取消这些操作，并把系统恢复到原先
			的状态。<br />
			<h3>ACTIVE OBJECT模式</h3>
			<div>
				ACTIVE OBJECT模式是实现多线程控制的一项古老的技术。该模式有多种使用方式，为许多工业系统提供了一个简单的多任务核心。
			</div>
			COMMAND模式的简单性掩盖了它的多功能性。COMMAND模式可以应用于多种不同的美妙用途，范围涉及数据库事务操作、设备控制、多线程核心以及GUI的do/undo管理。<br>
			有人认为COMMAND模式不符合面向对象的思维范式(paradigm )，因为它对函数的关注超过了类。这也许是真的，但是在实际的软件开发中，COMMAND模式是非常有用的。
		</div>
		
		<h2>第14章TEMPLATE METHOD模式和STRATEGY模式:继承与委托</h2>
		<div>
			继承非常容易被过度使用，而且过度使用的代价是非常高的。“优先使用对象组合(object composition)而不是类继承(class inheritance ) o "所以我们减少了对
			继承的使用，常常使用组合或者委托来代替它。<br />
			TEMPLATE METHOD模式和STRATEGY模式所要解决的问题是类似的，而且常常可以互换使用。不过，TEMPLATE METHOD模式使用继承来解决问题，而STRATEGY模式使用
			的则是委托。<br />
			TEMPLATE METHOD模式和STRATEGY模式都可以分离通用的算法和具体的上下文。在软件设计中经常会看到这样的需求。我们有一个通用的算法。为了遵循依赖倒置原则
			(DIP )，我们想确保这个通用的算法不要依赖于具体的实现。我们更想使这个通用的算法和具体的实现都依赖于抽象。
			<h3>TEMPLATE METHOD模式</h3>
			<div>
				TEMPLATE METHOD模式把所有通用代码放入一个抽象基类(abstract base class)的实现方法中。这个实现方法完成了这个通用算法，但是将所有的实现细节都交
				付给该基类的抽象方法。
			</div>
			<h3>滥用模式</h3>
			<div>
				设计模式是很好的东西。它们可以帮助解决很多设计问题。但是它们的存在并不意味着必须要经常使用它们。如果使用模式的代价要高于它所带来的好处，那么一味的
				追求设计模式是不明智的。

			</div>
			
			<h3>STRATEGY模式</h3>
			<div>
				STRATEGY模式使用了一种非常不同的方法来倒置通用算法和具体实现之间的依赖关系。他不是将通用的应用算法放进一个抽象基类中，而是将它放进另一个的具体类
				中。我们把通用算法必须要调用的抽象方法定义在一个接口中。我们从这个接口派生出各种算法策略，并把它传给通用算法。之后，通用算法就可以把具体工作委托
				给这个接口去完成。<br />
				STRATEGY模式比TEMPLATE METHOD模式多提供了一个额外的好处。尽管TEMPLATE METHOD模式允许一个通用算法操纵多个可能的具体实现，但是由于STRATEGY模
				式完全遵循DIP原则，从而允许每个具体实现都可以被多个不同的通用算法操纵。
			</div>
			<h3>结论</h3>
			<div>
				TEMPLATE METHOD模式和STRATEGY模式都可以用来分离高层的算法和低层的具体实现细节。都允许高层的算法独立于它的具体实现细节重用。此外，STRATEGY模式
				也允许具体实现细节独立于高层的算法重用，不过要以一些额外的复杂性、内存以及运行时间开销作为代价。
			</div>
			
			<h2>第15章 FACADE模式和MEDIATOR模式</h2>
			<div>
				如果策略涉及范围广泛并且可见，那么可以使用FACACE模式从上面施加该策略。另一方面，如果策略隐蔽并且有针对性，那么MEDIATOR模式是更好的选择。
				Facades通常是约定的关注点。每个人都同意去使用该facade而不是隐藏于其下的对象。另一方面，Mediator则对用户是隐藏的。它的策略是既成事实的而不是一
				项约定事务。
			</div>
			
			<h2>第16章 SINGLETON模式和MONOSTATE模式</h2>
			<div>
				常常会有必要强制要求某个特定对象只能具有单一实例。SINGLETON模式使用私有构造函数，一个静态变量，以及一个静态方法对实例化进行控制和限制。MONOSTATE
				模式只是简单地把对象的所有变量变成静态的。<br />
				如果希望透过派生去约束一个现存类，并且不介意它的所有调用者都必须要调用instance()方法来获取访问权，那么SINGLETON是最合适的。如果希望类的单一性本
				质对使用者透明，或者希望使用单一对象的多态派生对象，那么MONOSTATE是最适合的。
			</div>
			
			<h2>第17章 NULL OBJECT模式</h2>
			<div>
				那些长期使用C-based语言的人己经习惯于函数对某种失败返回null或者0。我们认为对这样的函数的返回值是需要检查的。NULL OBJECT模式改变了这一点。使用
				该模式，我们可以确保函数总是返回有效的对象，即使在它们失败时也是如此。这些代表失败的对象“什么也不做”。
			</div>
			
		</div>
	<body>
	</body>
</html>
