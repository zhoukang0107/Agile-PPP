<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第一部分 敏捷开发</title>
	</head>
	<body>
		<div>
			&nbsp;&nbsp;原则(principle )、模式(pattern )和实践(practice)都是重要的，但是使它们发挥作用的是人。正如Alistair Cnclcburm所说的。，“过程和方法对于项目的结果只有次要的影响,首要的影响是人。”<br>
			&nbsp;&nbsp;如果把程序员团队看做是由过程驱动的组件(cvmpanent)所组成的系统，那么就无法对它们进行管理。人不是“插入即兼容的编程装置。”如果想要项目取得成功，就必须构建起具有合作精神的、自组织( self-organizing)的团队。
		</div>
		<h2>第1章 敏捷实践</h2>
		<div>
			&nbsp;&nbsp;没有实践指导或者缺乏有效的实践都会导致项目出现不可预测性、重复的错误，进而导致项目的延期，预算的增加乃至客户信心的丧失，更长时间的工作却生产出低劣的软件产品，这也是开发人员感到沮丧。<br>
			&nbsp;&nbsp;缺乏实践指导造成的后果激发我们创建一些过程来约束我们的活动，我们根据过去的经验来规定这些约束和输出，挑选那些在以前的项目中看起来好像工作的不错的方法，希望在这次也会生效，来降低我们项目失败的可能性。<br>
			&nbsp;&nbsp;但是项目并不是简单到使用一些约束和规定就能够可靠地方式错误的发生，当连续出现错误时，我们对错误进行分析诊断，进而增加更多的约束和规定来防止以后重犯这类错误。如此往复，常常导致我们项目过程变得笨重，极大削弱
			我们完成工作的能力.<br>
			&nbsp;&nbsp;一个大而笨重的过程会产生它本来企图去解决的问题。它降低了团队的开发效率，使得进度延期，预算超支。它降低了团队的响应能力，使得团队经常创建错误的产品。遗憾的是，许多团队认为，这种结果是因为他们没有采用更多的
			过程方法引起的。因此，在这种失控的过程膨胀中。过程会变得越来越庞大。
		</div>
		<h3>
			1.1 敏捷联盟
		</h3>
		<div>
			&nbsp;&nbsp;由于许多公司的软件团队陷入了不断增长的过程的泥潭，一批业界专家聚集在一起概括出了一些可以让软件开发团队具有快速工作、响应变化能力的价值观(value)和原则。他们称自己为敏捷(Agile)联盟口.在随后的几个月中，他们
			创建出了一份价值观声明。也就是敏捷联盟宣言(The Manifests of the Agile Alliance)。<br>
			<h5>
				敏捷联盟宣言
			</h5>
			<div>
				&nbsp;&nbsp;我们正在通过亲身实践以及帮助他人实践，揭示更好的软件开发方法，通过这项工作，我们认为:<br>
				<li>个体和交互胜过过程和工具</li>
				<li>可以工作的软件胜过面面俱到的文档</li>
				<li>客户合作胜过合同谈判</li>
				<li>响应变化胜过遵循计划</li>
				虽然右项也有价值，但是我们认为左项具有更大的价值。
			</div>
			<h6>
				1 个体和交互胜过过程和工具
			</h6>
			<div>
				&nbsp;&nbsp;人是获得成功的最为重要的因素。如果团队中没有优秀的成员，那么就是使用好的过程也不能从失败中挽救项目，但是，不好的过程却可以使最优秀的团队成员失去效用。如果不能作为一个团队进行工作，那么即使拥有一批优秀
				的成员也一样会惨败。<br />
				&nbsp;&nbsp;一个优秀的团队成员未必就是一个一流的程序员。一个优秀的团队成员可能是一个平均水平的程序员，但是却能够很好地和他人合作。合作、沟通以及交互能力要比单纯的编程能力更为重要。一个由平均水平程序员组成的团队，
				如果具有良好的沟通能力，将要比那些虽然拥有一批高水平程序员，但是成员之间却不能进行交流的团队更有可能获得成功。<br />
				&nbsp;&nbsp;合适的工具对于成功来说是非常重要的。工具的作用可能会被过分地夸大。使用过多的庞大、笨重的工具就像缺少工具一样，都是不好的。<br>
				&nbsp;&nbsp;我们的建议是从使用小工具开始，尝试一个工具，直到发现它无法适用时才去更换它。<br>
				&nbsp;&nbsp;记住，团队的构建要比环境的构建重要得多。许多团队和管理者就犯了先构建环境，然后期望团队自动凝聚在一起的错误。相反，应该首先致力于构建团队，然后再让团队基于需要来配置环境。
			</div>
			<h6>2 可以工作的软件胜过面面俱到的文档</h6>
			<div>
				&nbsp;&nbsp;没有文档的软件是一种灾难。代码不是传达系统原理和结构的理想媒介。团队更需要编制易于阅读的文档，来对系统及其设计决策的依据进行描述。<br>
				&nbsp;&nbsp;然而，过多的文档比过少的文档更糟。编制众多的文档需要花费大量的时间，并且要使这些文档和代码保持同步，就要花费更多的时间。如果文档和代码之间失去同步，那么文档就会变成庞大的、复杂的谎言，会造成重大的误导。<br />
				&nbsp;&nbsp;对于团队来说，编写并维护一份系统原理和结构方而的文档将总是一个好主意，但是那份文档应该是短小的(short )并且主题突出的()Salient ) “短小的”意思是说，最多有二二十页。“主题突出的”意思是说，应该仅论述系统
				的高层结构和概括的设计原理。<br />
				&nbsp;&nbsp;对于新的团队成员的培训，我们会非常密切地和他们在一起工作。我们紧挨着他们坐下来帮助他们，把我们的知识传授给他们口我们通过近距离的培训和交互使他们成为团队的一部分。在给新的团队成员传授知识方面，最好的两
				份文档是代码和团队。代码真实地表达了它所做的事情。虽然从代码中提取系统的原理和结构信息可能是困难的，但是代码是惟一没有二义性的信息源。在团队成员的头脑中，保存着时常变化的系统的脉络图( raad map )。人和人之间的交互
				是把这份脉络图传授给他人的最快、最有效的方式。<br />
				&nbsp;&nbsp;许多团队因为注重文档而非软件，导致进度拖延。这常常是一个致命的缺陷。有一个叫做“Martin文档第一定律(Martin's first law of document)”的简单规则可以预防该缺陷的发生:<br />
				<font color="red">到迫切需要并且意义重大时，才来编制文档。</font>
			</div>
				<h6>3 客户合作胜过合同谈判</h6>
			<div>
				&nbsp;&nbsp;告诉开发团队想要的东西，然后期望开发团队消失一段时间后就能够交付一个满足需要的系统来，这对于公司的管理者来说是具有诱惑力的。然而，这种操作模式将导致低劣的质量和失败。<br />
				&nbsp;&nbsp;成功的项目需要有序、频繁的客户反馈。不是依赖于合同或者关十工作的陈述，而是让软件的客户和开发团队密切地在一起工作，并尽量经常地提供反馈。<br>
				&nbsp;&nbsp;一个指明了需求、进度以及项目成本的合同存在根本上的缺陷。在大多数的情况下合同中指明的条款远在项目完成之前就变得没有意义。那些为开发团队和客户的协同工作方式提供指导的合同才是最好的合同。<br />
				&nbsp;&nbsp;项目成功的关键在于和客户之间真诚的协作，并且合同指导了这种协作，而不是试图去规定项目范围的细节和固定成本下的进度。<br />
			</div>
				<h6>4 响应变化胜过遵循计划</h6>
			<div>
				&nbsp;&nbsp;响应变化的能力常常决定着个软件项目的成败。当我们构建计划时，应该确保计划是灵活的并且易于适应商务和技术方面的变化。<br />
				&nbsp;&nbsp;计划不能考虑得过远口首先，商务环境很可能会变化，这会引起需求的变动。其次，一旦客户看到系统开始运作，他们很可能会改变需求。最后，即使我们熟悉需求，并且确信它们不会改变，我们仍然不能很好地估算出开发它们需
				要的时间。<br />
				&nbsp;&nbsp;较好的做计划的策略是:为下两周做详细的计划，为下三个月做粗略的计划，再以后就做极为粗糙的计划。我们应该清楚地知道下两周要完成的任务，粗略地了解下以后三个月要实现的需求。至于系统一年后将要做什么，有一个模
				糊的想法就行了。<br />
				&nbsp;&nbsp;计划中这种逐渐降低的细致度，意味着我们仅仅对于迫切的任务才花费时间进行详细的计划。一旦制定了这个详细的计划，就很难进行改变，因为团队会根据这个计划启动工作并有了相应的投入。然而，由于计划仅仅支配了几周
				的时间，计划的其余部分仍然保持着灵活性。<br />
			</div>
		</div>
		<h3>1.1 原则</h6>
		<div>
			&nbsp;&nbsp;从上述的价值观中引出了下面的12条原则，它们是敏捷实践区别于重型过程的特征所在。 <br />
			<h5>1 我们最优先要傲的是通过尽早的、持续的交付有价值的软件来使客户满意。</h5>
			<div>
				&nbsp;&nbsp;敏捷实践会尽早地、经常地进行交付。我们努力在项目刚开始的几周内就交付一个具有基本功能的系统。然后，我们努力坚持每两周就交付一个功能渐增的系统。如果客户认为目前的功能己经足够了，客户可以选择把这些系统
				加入到产品中。或者，他们可以简单地选择再检查一遍已有的功能，并指出他们想要做的改变。<br />
			</div>
			<h5>2 即使到了开发的后期，也欢迎改变孺求。敏捷过程利用变化来为客户创造竞争优势。</h5>
			<div>
				&nbsp;&nbsp;这是一个关于态度的声明。敏捷过程的参与者不惧怕变化。他们认为改变需求是好的事情，因为那些改变意味着团队己经学到了很多如何满足市场需要的知识。敏捷团队会非常努力地保持软件结构的灵活性，这样当需求变化时，
				对于系统造成的影响是最小的。<br />
			</div>
			<h5>3 经常性地交付可以工作的软件，交付的间诵可以从几周到几个月，交付的时间间诵越短越好。</h5>
			<div>
				&nbsp;&nbsp;我们交付可以工作的软件(working softwaae )，并且尽早地(项目刚开始很少的几周后)、经常性地(此后每隔很少的几周)交付它。我们不赞成交付大量的文档或者计划。我们认为那些不是真正要交付的东西。我们关注的目
				标是交付满足客户需要的软件。<br />

			</div>
			<h5>4 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。</h5>
			<div>
				&nbsp;&nbsp;为了能够以敏捷的方式进行项目的开发;客户、开发人员以及涉众之间就必须要进行有意义的、频繁的交互。软件项目不像发射出去就能自动导航的武器，必须要对软件项目进行持续不断地引导。<br />
			</div>
			<h5>5 围绕被激励起来的个人来构建项目。给他们提供所孺要的环境和支持，并且信任他们能够完成工作。</h5>
			<div>
				&nbsp;&nbsp;在敏捷项目中，人被认为是项目取得成功的最重要的因素。所有其他的因素—过程、环境、管理等等—都被认为是次要的，并且当它们对于人有负面的影响时，就要对它们进行改变。<br />
			</div>
			<h5>6 在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈。</h5>
			<h5>7 工作的软件是首要的进度度量标准。</h5>
			<div>
				&nbsp;&nbsp;敏捷项目通过度量当前软件满足客户需求的数量来度量开发进度。它们不是根据所处的开发阶段、己经编写的文档的多少或者己经创建的基础结构(infras}ucture)代码的数量来度量开发进度的。只有当30%的必须功能可以工作时，才
				可以确定进度完成了30%。<br />
			</div>
			<h5>8 敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。</h5>
			<div>
				&nbsp;&nbsp;敏捷项目不是50米短跑;而是马拉松长跑。团队不是以全速启动并试图在项目开发期间维持那个速度；相反，他们以快速但是可持续的速度行进。<br />
				&nbsp;&nbsp;跑得过快会导致团队精力耗尽、出现短期行为以致于崩溃。敏捷团队会测量他们自己的速度。他们不允许自己过于疲惫。他们不会借用明天的精力来在今天多完成一点工作。他们工作在一个可以使在整个项目开发期间保持最高质
				量标准的速度上。<br />
			</div>
			<h5>9 不断地关注优秀的技能和好的设计会增强敏捷能力。</h5>
			<h5>10 简单—使未完成的工作最大化的艺术一一是根本的.</h5>
			<div>
				&nbsp;&nbsp;敏捷团队不会试图去构建那些华而不实的系统，他们总是更愿意采用和目标一致的最简单的方法。他们并不看重对于明天会出现的问题的预测，也不会在今天就对那些问题进行防卫。相反，他们在今天以最高的质量完成最简单的
				工作，深信如果在明天发生了问题，也会很容易进行处理。<br />
			</div>
			<h5>11 最好的构架、需求和设计出自于自组织的团队。</h5>
			<div>
				&nbsp;&nbsp;敏捷团队是自组织的团队。任务不是从外部分配给单个团队成员，而是分配给整个团队，然后再由闭队来确定完成任务的最好方法。<br />
				&nbsp;&nbsp;敏捷团队的成员共同来解决项目中所有方面的问题。每一个成员都具有项目中所有方面的参与权力。不存在单一的团队成员对系统构架、需求或者测试负责的情况。整个团队共同承担那些责任，每一个团队成员都能够影响它们。<br />
				
			</div>
			<h5>12 每隔一定时间。团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。</h5>
		</div>
		<h3>1.3 结论</h3>
		<div>
			&nbsp;&nbsp;每一位软件开发人员、每一个开发团队的职业目标，都是给他们的雇主和客户交付最大可能的价值。可是，我们的项目以令人沮丧的速度失败，或者未能交付任何价值。虽然在项目中采用过程方法是出于好意的，但是膨胀的过程力一
			法对于我们的失败至少是应该负一些责任的。敏捷软件开发的原则和价值观构成了一个可以帮助团队打破过程膨胀循环的方法，这个方法关注的是可以达到团队目标的一些简单的技术。
		</div>
		<h2>
			第二章 极限编程概述
		</h2>
		<h5>
			2.1 极限编程实践
		</h5>
		<div>
			&nbsp;&nbsp;极限编程C eX#reme Programming，简称XP)是敏捷方法中最著名的一个。它由一系列简单却互相依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。<br />
		</div>
		<h6>
			2.1.1 客户作为团队成员
		</h6>
		<div>
			&nbsp;&nbsp;我们希望客户和开发人员在一起紧密地工作，以便于彼此知晓对方所面临的问题，并共同去解决这些问题。<br />
			&nbsp;&nbsp;谁是客户?XP团队中的客户是指定义产品的特性并排列这些特性优先级的人或者团体。有时，客户是和开发人员同属一家公司的一组业务分析师或者市场专家。有时，客户是用户团体委派的用户代表。有时，客户事实上是支付开发费
			用的人口但是在XP项目中，无论谁是客户，他们都是能够和团队一祝工作的团队成员。<br />
		</div>
		<h6>
			2.1.2 用户素材
		</h6>
		<div>
			&nbsp;&nbsp;为了进行项目计划，必须要知道和项目需求有关的内容，但是却无需知道得太多。对于做计划而言，了解需求只需要做到能够估算它的程度就足够了。你可能认为，为了对需求进行估算，就必须要了解该需求的所有细节，其实并非如
			此。你必须要知道存在很多细节，也必须要知道细节的大致分类，但是你不必知道特定的细节。<br />
			&nbsp;&nbsp;需求的特定细节很可能会随时间而改变，一旦客户开始看到集成到一起的系统，就更会如此。看到新系统的问世是关注需求的最好时刻。因此，在离真正实现需求还很早时就去捕获该需求的特定细节，很可能会导致做无用功以及对需
			求不成熟的关注。<br>
			&nbsp;&nbsp;用户素材(user stories)就是正在进行的关于需求谈话的助记符。它是一个计划工具，客户可以使用它并根据它的优先级和估算代价来安排实现该需求的时间。<br />
		</div>
		<h6>
			2.1.3 短交付周期
		</h6>
		<div>
			&nbsp;&nbsp;XP项目每两周交付一次可以r-作的软件。每两周的迭代(iteration，也可称为重复周期或循环周期)都实现了涉众的一些需求。在每次迭代结束时，会给涉众演示迭代生成的系统，以得到他们的反馈。<br />
			&nbsp;&nbsp;<li>迭代计划</li><br />
			&nbsp;&nbsp;每次迭代通常耗时两周。这是一次较小的交付，可能会被加入到产品中。也可能不会。它由客户根据月毛发人员确定的预算而选择的一些用户素材组成。<br />
			&nbsp;&nbsp;开发人员通过度量在以前的迭代中所完成的工作量来为木次迭代设定预算。只要估算成本的总量不超过预算，客户就可以为本次迭代选择任意数量的用户素材。<br />
			&nbsp;&nbsp;一旦迭代开始，客户就同意不再修改当次迭代中用户素材的定义和优先级别。迭代期间，开发人员可以自由地将用户素材分解成任务(task),并依据最具技术和商务意义的顺序来开发这些任务。<br />
			&nbsp;&nbsp;<li>发布计划</li><br />
			&nbsp;&nbsp;XP团队通常会创建一个计划来规划随后大约6次迭代的内容，这就是所谓的发布计划。一次发布通常需要3个月的工作。它表示了一次较大的交付，通常此次交付会被加入到产品中。发布计划是由一组客户根据开发人员给出的预算所选
			择的、排好优先级别的用户素材组成。<br />
			&nbsp;&nbsp;开发人员通过度量在以前的发布中所完成的工作量来为本次发布设定预算。只要估算成本的总量不超过预算，客户就可以为木次发布选择任意数目的用户素材。客户同样可以决定在本次发布中用户素材的实现顺序。如果开发人员强烈
			要求的话，客户可以通过指明哪些用户素材应该在哪次迭代中完成的方式，制订出发布中最初几次迭代的内容。<br />
			&nbsp;&nbsp;发布计划不是一成不变的，客户可以随时改变计划的内容。他可以取消用户素材，编写新的用户素材，或者改变用户素材的优先级别。<br />
		</div>
		<h6>
			2.1.4 验收测试
		</h6>
		<div>
			&nbsp;&nbsp;可以以客户指定的验收测试(Acceptance Tests)的形式来捕获有关用户素材的细节口用户索材的验收测试是在就要实现该用户素材之前或实现该用户素材的同时进行编写的。<br />
			&nbsp;&nbsp;一旦通过一项验收测试，就将该测试加入到已经通过的验收测试集合中，并决不允许该测试两次失败。这个不断增长的验收测试集合每天会被多次运行，每当系统被创建时，都要运行这个验收测试集。如果一项验收测试失败了，那么
			系统创建就宣告失败。因而，一项需求一以被实现，就再不会遭到破坏。系统从一种工作状态变迁到另一种工作状态，期间，系统的不能工作作状态时间决不允许超过几个小时。<br />
		</div>
		<h6>
			2.1.5 结对编程
		</h6>
		<div>
			&nbsp;&nbsp;所有的产品(production)代码都是由结对的程序员使用同一台电脑共同完成的。结对人员中的一位控制键盘并输入代码，另一位观察输入的代码并寻找着代码中的错误和可以改进的地方。两个人强烈地进行着交互，他们都全身心地
			投入到软件的编写中。<br />
			&nbsp;&nbsp;两人频繁互换角色。控制键盘的可能累了或者遇到了困难，他的同伴会取得键盘的控制权。在一个小时内，键盘呵能在他们之问来回传递好几次。最终生成的代码是由他们两人共同设计、共同编写的，两人功劳均等。<br />
			&nbsp;&nbsp;结对的关系每天至少要改变一次，以便于每个程序员在一天中可以在两个不同的结对中上作。在一次迭代期间，每个团队成员应该和所有其他的团队成员在一起工作过，并且他们应该参与了本次迭代中所涉及的每项工作。<br />
			&nbsp;&nbsp;这将极大地促进知识在团队中的传播。仍然会需要一些专业知识，并且那些需要一定专业知识的任务通常需要合适的专家去完成，但是那些专家几乎会和团队中的所有其他人结过对。这将加快专业知识在团队中的传播。这样，在紧要
			关头，其他团队成员就能够代替所需要的专家。<br />
			&nbsp;&nbsp;研究表明，结对非但不会降低开发团队的效率，而且会大大减少缺陷率。<br />
		</div>
		<h6>
			2.1.6 测试驱动的开发方法
		</h6>
		<div>
			&nbsp;&nbsp;编写所有产品代码的日的都是为了使失败的单元测试能够通过。首先编写一个单元测试，由于它要测试的功能还不存在，所以它会运行失败。然后，编写代码使测试通过。<br />
			&nbsp;&nbsp;编写试用例和代码之I}}的更迭速度是很快的，基本上几分钟左右。测试用例和代码共同演化，其中测试用例循序渐进地对代码的编写进行指导。<br />
			&nbsp;&nbsp;作为结果，一个非常完整的测试用例集就和代码一起发展起来。程序员可以使用这些测试来检查程序是否正确工作。如果结对的程序员对代码进行了小的更改，那么他们可以运行测试，以确保更改没有对一程序造成任何的破坏。这会
			非常有利于重构。<br />
			&nbsp;&nbsp;当为了使测试用例通过而编写代码时，这样的代码就被定义为可测试的代码。这样做会强烈地激发你去解除各个模块间的耦合，这样能够独地对它们进行测试。因而，以这种方式编写的代码的设计往徉藕合性较弱。面向对象设计的原
			则在进行这种解除耦合方面具有巨大的帮助作用。<br />
		</div>
		<h6>
			2.1.7 集体所有权
		</h6>
		<div>
			&nbsp;&nbsp;结对编程中的每一对都具有拆出(check out)任何模块并对它进行改进的权力。没有程序员对任何·个特定的模块或技术单独负责。每个人都参与}m方面的r:作;},每个人都参与中间件方面的工作;每个人都参与数据库方面的工作。
			没有人比其他人在一个模块或者技术上具有更多的权威。<br />
			&nbsp;&nbsp;这并不意味着XP不需要专业知识。如果你的专业领域是有关GUI的，那么你最有可能去从事GUI方面的任务，但是你将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定去学习另一门专业知识，那么你可以承担相
			关的任务，并和能够传授你这方面知识的专家一起工作。你不会被限制在自己的专业领域。<br />
		</div>
		<h6>
			2.1.8 持续集成
		</h6>
		<div>
			&nbsp;&nbsp;程序员每天会多次拆入(Check in)他们的代码并进行集成，规则很简单。第一个拆入的只要完成拆入轨可以了，所有其他的人负责代码的合井( merge)工作、<br />
			&nbsp;&nbsp;XP团队使用非阻塞的(nonblocking )源代码控制工具。这意味着程序员可以在任何时候拆出任何模块，而不管是否有其他人已经拆出这个模块。当程序员完成对模块的修改井把该模块拆入回去时，他必须要把他所做的改动和在他前
			面拆入该模块的程序员所做的任何改动进行合并。为了避兔合并的时间过长，团队的成员会非常频繁地拆入他们的模块。<br />
			&nbsp;&nbsp;结对人员会在一项任务卜工作1}2个小时。他们创建测试用例和产品代码。在某个适当的间歇点，也许远远在这项任务完成之前，他们决定把代码拆入回去。最重要的是要确保所有的测试都能够通过。他们把新的代码集成进代码库中。
			如果需要，他们会对代码进行合并。如果有必要，他们会和先于他们拆入的程序员协商。一旦集成进了他们的更改，他们就构建新的系统。他们运行系统中的每一个测试，包括当前所有运行着的验收测试。如果他们破坏了原先可以工作的部分，他
			们会进行修正。一旦所有的测试都通过了，他们就算完成了此次拆入工作。<br />
			
		</div>
		<h6>
			2.1.9 可持续的开发速度
		</h6>
		<div>
			&nbsp;&nbsp;软件项目不是全速的短跑，它是马拉松长跑。那些一跃过起跑线就开始尽力狂奔的团队在远离终点前就会筋疲力尽。为了快速地完成开发，团队必须要以一种可持续的速度前进。团队必须保持旺盛的精力和敏锐的警觉。团队必须要有
			意识地保持稳定、适中的速度。<br />
			&nbsp;&nbsp;XP的规则是不允许团队加班工作。在版本发布前的一个星期是该规则的惟一例外。如果发布目标就在眼前并且能够一激而就，则允许加班。<br />
		</div>
		<h6>
			2.1.10 开放的工作空间
		</h6>
		<div>
			&nbsp;&nbsp;团队在一个开放的房间中一起工作。房间里充满了交谈的嗡嗡声，结对编程的两人坐在互相能够听得到的距离内，每个人都可以得知另一人何时遇到了麻烦，每个人都了解对方的工作状态，程序员们都处在适合于激烈地进行讨论的位
			置上。<br />
		</div>
		<h6>
			2.1.11 计划游戏
		</h6>
		<div>
			&nbsp;&nbsp;计划游戏( planning game)的本质是划分业务人员和开发人员之间的职责。业务人员(也就是客户)决定特性(feature)的重要性，开发人员决定实现一个特性所花费的代价。<br />
			&nbsp;&nbsp;在每次发布和每次迭代的开始，开发人员基于在最近一次迭代或者最近一次发布中他们所完成的工作量，为客户提供一个预算,客户选择那些所需的成本合计起来不超过该预算的用户素材<br />
			&nbsp;&nbsp;依据这些简单的规则，采用短周期迭代和频繁的发布。很快客户和开发人员就会适应项目的开发节奏。客户会了解开发人员的开发速度。基十这种了解，客户能够确定项目会持续多长时间，以及会花费多少成本。<br />
		</div>
		<h6>
			2.1.12 简单的设计
		</h6>
		<div>
			&nbsp;&nbsp;XP团队使他们的设计尽可能地简单、具有表现力(expressiae )。此外，他们仅仅关注于计划在本次迭代中要完成的用户素材。他们不会考虑那些未来的用户素材。相反，在一次次的迭代中，他们不断变迁系统设计，使之对正在实
			现的用户素材而言始终保持在最优状态。<br />
			&nbsp;&nbsp;这意味着XP团队的工作可能不会从基础结构开始，他们可能并不先去选择使用数据库或者中间件。团队最开始的工作是以尽可能最简单的方式实现第一批用户素材。只有当出现一个用户素材迫切需要基础结构时，他们才会引入该基础
			结构。<br />
			&nbsp;&nbsp;下面三条XP指导原则(mantras)可以对开发人员进行指导。<br />
			&nbsp;&nbsp;<li>考虑能够工作的最简单的事情</li><br />
			&nbsp;&nbsp;XP团队总是尽可能寻找能实现当前用户素材的最简单的设计。在实现当前的用户素材时，如果能够使用平面文件，就不去使用数据库或者EJB(企业级Java Bear);如果能够使用简单的socket连接，就不去使用DRB(对象请求代理)或
			者RMI(远程方法调用):如果能够不使用多线程，就别去用它。我们尽量考虑用最简单的方法来实现当前的用户素材。然后，选择一种我们能够实际得到的和该简单方法最接近的解决方案。<br />
			&nbsp;&nbsp;<li>你将不需要它</li><br />
			&nbsp;&nbsp;如果在确实需要基础结构前拒绝引入它，那么会发生什么昵?XP团队会对此进行认真的考虑。他们开始时假设将不需要那些基础结构。只有在有证据，或者至少有十分明显的迹像表明现在引入这些基础结构比继续等待更加合算时，团队
			才会引入这些基础结构。<br />
			&nbsp;&nbsp;<li>一次，并且只有一次</li><br />
			&nbsp;&nbsp;极限编程者不能容忍重复的代码。无论在哪里发现重复的代码，他们都会消除它们。消除重复最好的力一法就是抽象。毕竟，如果两种事物相似的话，必定存在某种抽象能够统一它们。这样，消除重复的行为会迫使团队提炼出许多的
			抽象，并进一步减少了代码问的藕合。<br />
		</div>
		<h6>
			2.1.13 重构
		</h6>
		<div>
			&nbsp;&nbsp;代码往往会腐化。随着我们添加一个又一个的特性，处理一个又一个的错误，代码的结构会逐渐退化。如果对此置之不理的话，这种退化最终会导致纠结不清，难于维护的混乱代码。<br />
			&nbsp;&nbsp;XP团队通过经常性的代码生构来扭转这种退化。重构就是在不改变代码行为的前提下，对其进行一系列小的改造( transforn}atian ) ,旨在改进系统结构的实践活动。每个改造都是微不足道的，几乎不值得去做。但是所有的这此
			改造叠加在一起，就形成了对系统设计和构架显著的改进。<br />
			&nbsp;&nbsp;在每次细微改造之后，我们运行单元测试以确保改造没有造成任何破坏，然后再去做下一次改造、如此往复，周而复始，每次改造之后都要运行测试。通过这种方式，我们可以在改造系统设计的同时，保持系统可以工作。<br />
			&nbsp;&nbsp;重构是持续进行的，而不是在项目结束时、发布版本时，迭代结束时、甚至每天快下班时才进行的。重构是我们每隔一个小时或者半个小时就要去做的事情。通过重构，我们可以持续地保持尽可能干净、简单并且具有表现力的代码。<br />
		</div>
		<h6>
			2.1.14 隐喻
		</h6>
		<div>
			&nbsp;&nbsp;极限编程者在本质上都是务实主义者，隐喻，它是将整个系统联系在一起的全局视图;它是系统的未来景像，是它使得所有单独模块的位置和外观(snapc)变得明显直观。如果模块的外观与整个系统的隐喻不符，那么你就知道该模块是错误的。<br />
			&nbsp;&nbsp;隐喻通常可以归结为一个名字系统。这些名字提供了一个系统组成元素的词汇表，并且民有助于定义它们之间关系。<br />
		</div>
		<h3>
			第三章 计划
		</h3>
		<div>
			&nbsp;&nbsp;通过一次次的迭代和发布，项目进入了一种可以预测的、舒适的开发节奏。每个人都知道将要做什么，以及何时去做。涉众经常地、实实在在地看到项目的进展。他们看到的不是画满了图、写满了计划的记事本，而是可以接触到、感
			觉到的可以工作的软件，并且他们还可以对这个软件提供自己的反馈。<br />
			&nbsp;&nbsp;开发人员看到的是基于他们自己的估算并且由他们自己度量的开发速度控制的合理的计划。他们选择他们感觉舒适的任务，并保持高的工作质量。<br />
			&nbsp;&nbsp;管理人员从每次迭代中获取数据，他们使用这些数据来控制和管理项目。他们不必采用强制、威胁或者恳求开发人员忠心的方式去达到一个武断的、不切实际的目标。<br />
			&nbsp;&nbsp;这听起来好像是美好轻松的，其实不是这样。涉众对过程产生的数据并不总是满意的，特别是在刚刚开始时。使用敏捷方法并不意味着涉众就可以得到他们想要的。它只不过意味着他们将能够控制着团队以最小的代价获得最大的商业价值。<br />
			&nbsp;&nbsp;<br />
		</div>
		<h3>
			第四章 测试
		</h3>
		<div>
			&nbsp;&nbsp;测试可以提高代码的可靠性，为了是代码可测促使模块之间隔离，模块间解耦。<br />
			&nbsp;&nbsp;测试套件运行起来越简单，就会越频繁地运行它们。测试运行得越多，就会越快地发现和那些测试的任何背离。如果能够一天多次地运行所有的测试，那么系统失效的时间就决不会超过几分钟。这是一个合理的目标。我们决不允许系统倒退。
			一旦它工作在一个确定的级别上，就决不能让它倒退到一个稍低的级别。<br />
			&nbsp;&nbsp;然而，验证仅仅是编写测试的好处之一。单元测试和验收测试都是一种文档形式，那样的文档是可以编译和执行的;因此，它是准确和可靠的。此外，编写测试所使用的语言是明确的，并且它们的观看者使这些语言非常易读。程序员能
			够阅读单元测试，因为单元测试是使用程序员编程的语言编写的。客户能够阅读验收测试，因为验收测试是使用客户自己设计的语言编写的。<br />
			&nbsp;&nbsp;也许，测试最重要的好处就是它对于构架和设计的影响。为了使一个模块或者应用程序具有可测试性，必须要对它进行解祸合。越是具有可测试性，祸合关系就越弱。全面地考虑验收测试和单元测试的行为对于软们一的结构具有深远
			的正面影响。<br />
		</div>
		<h3>
			第五章 重构
		</h3>
		<div>
			&nbsp;&nbsp;每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。这也是该模块得以存在的原因。第二个职责是它要应对变化。几乎所有的模块在它们的生命周期中都要变化，开发者有责任保证这种改变应该尽可能地简单。
			一个难以改变的模块是拙劣的，即使能够工作，也需要对它进行修正。第三个职责是要和阅读它的人进行沟通。对该模块不熟悉的开发人员应该能够比较容易地阅读并理解它。一个无法进行沟通的模块也是拙劣的，同样需要对它进行修正。<br />
			&nbsp;&nbsp;重构就好比用餐后对厨房的清理工作。第一次你没有清理它，你用餐是会快一点。但是由于没有对盘碟和用餐环境进行清洁，第二天做准各工作的时间就要更长一点。这会再一次促使你放弃清洁工作。的确，如果跳过清洁工作，你今
			犬总是能够很快用完餐，但是脏乱在一天天的积累。最终，你得花费人量的时间去寻找合适的烹饪器具，凿去盘碟上已经干硬的食物残余，并把它们洗擦千净以使它们适合于烹饪口饭是天天要吃的。忽略掉清洁工作并不能真正加快做饭速度。<br />
			&nbsp;&nbsp;重构的目的，是为了每天清洁你的代码。我们不想让脏乱累积，我们不想“凿去并洗擦掉”随着时间累积的“干硬的”比特，我们想通过最小的努力就能够对我们的系统进行扩展和修改。要想具有这种能力，最重要的就是要保持代码的清洁。<br />
		</div>
	</body>
</html>
