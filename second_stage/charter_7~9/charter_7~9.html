<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第二部分 敏捷设计</title>
	</head>
	<body>
		<h1>第二部分 敏捷设计</h1>
		<div>
			在敏捷团队中，全局视图和软件一起演化。在每次迭代中，团队改进系统设计，使设计尽可能适合于当前系统。团队不会花费许多时间去预测未来的需求和需要，也不会试
			图在今天就构建一些基础结构去支撑那些他们认为明天才会需要的特性。他们更愿意关注当前的系统结构，并使它尽可能地好。
		</div>
		<h4>拙劣设计的症状</h4>
		<div>
			拙劣设计症状主要表现如下:
			<li>僵化性(Rigidity ):设计难以改变。</li>
			<li>脆弱性(Fragility ):设计易于遭到破坏。</li>
			<li>牢固性(Immobility ):设计难以重用。</li>
			<li>粘滞性(Viscosity ):难以做正确的事情。</li>
			<li>不必要的复杂性(Needless Complexity ):过分设计。</li>
			<li>不必要的重复(Needless Repetition):滥用鼠标。</li>
			<li>晦涩性(Opacity )混乱的表达。</li>
			这些症状在本质上和代码的“臭味”(smell )相似，但是它们所处的层次稍高一些。它们是遍及整个软件结构的臭味，而不仅仅是一小段代码。
		</div>
		<h4>原则</h4>
		<div>
			面向对象设计的原则有助于开发人员消除设计中的臭味，并为当前的特性集构建出最好的设计。<br>
			这些原则如下:<br />
			<li>单一职责原则(The Single Responsibility Principle，简称SRP)</li>
			<li>开放一封闭原则(The Open-Close Principle，简称OCP)</li>
			<li>Liskov替换原则(The Liskov Substitution Principle，简称LSP)</li>
			<li>依赖倒置原则(The Dependency Inversion Principle，简称DIP )</li>
			<li>接口隔离原则(The Interface Segregation Interface，简称ISP)</li>
		</div>
		<h4>臭味和原则</h4>
		<div>
			设计中的臭味是一种症状，是可以主观(如果不能客观的话)进行度量的。这些臭味常常是由于违反了这些原则中的一个或者多个而导致的。<br />
			敏捷团队应用这些原则来除去臭味。当没有臭味时，他们不会应用这些原则。仅仅因为是一个原则就无条件的去遵循它的做法是错误的。这些原则不是可以随意在系统中到
			处喷洒的香水。过分遵循这些原则会导致不必要的复杂性(Needless Complexity)的设计臭味。
		</div>
		
		
		<h2>第7章 什么是敏捷设计</h2>
		<div>
			<h3>7.1 软件出了什么错</h3>
			<div>
				如果幸运，你会在项目开始时就有了想得到的系统的清晰图像。系统的设计是存在于你头脑中的图像。如果更幸运一点，在首次发布(release)时，设计依然保持清
				楚。<br />
				接着，事情开始变糟。软件像一片坏面包一样开始腐化。随着时间的流失，腐化蔓延、增长。丑陋腐烂的痛处和疖子在代码中累积，使它变得越来越难以维护。最后，
				即使仅仅进行最简单的更改，也需要花费巨大的努力，以至于开发人员和一线( front-line )管理人员强烈要求重新设计。<br />
				这样的重新设计很少会成功。虽然设计人员开始时出于好意，但是他们发现自己正朝一个移动的目标射击。老系统不断地发展、变化，而新的设计必须得跟上这些变
				化。这样，甚至在第一次发布前，新的设计中就累积了很多的瑕疵和弊病。
			</div>
			
			<h3>7.2 设计的臭味—腐化软件的气味</h3>
			<div>
				当软件出现下面任何一种气味时，就表明软件正在腐化。<br />
				<h5>僵化性(Rigidity ):很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的其他改动。</h5>
				<div>
					如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。必须要改动的模块越多，设计就越僵化。<br>
					大部分的开发人员都以这样或者那样的方式遇到过这种情况。他们会被要求进行一个看起来简单的改动。他们看了看这个改动并对所需的工作做出了一个合理的
					估算。但是过了一会儿，当他们实际进行改动时，会发现有许多改动带来的影响自己并没有预测到。他们发现自己要在庞大的代码中搜寻这个变动，并且要更改
					的模块数目也远远超出最初估算。最后，改动所花费的时间要远比初始估算长。当问他们为何估算得如此不准确时，他们会重复软件开发人员惯用的悲叹，“它
					比我想像的要复杂得多!”
				</div>
				<h5>脆弱性(Fragility )对系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题。</h5>
				<div>
					常常是，出现新问题的地方与改动的地方并没有概念上的关联。要修正这些问题就又会引出更多的问题，从而使开发团队就像一只不停追逐自己尾巴的狗一样
					(忙得团团转)。<br>
					随着模块脆弱性的增加，改动会引出意想不到的问题的可能性就越来越大。这看起来很荒谬，但是这样的模块是非常常见的。这些模块需要不断地修补—它们从
					来不会被从错误列表中去掉，开发人员知道需要对它们进行重新设计(但是谁都不愿意去面对重新设计中的难以琢磨性)，你越是修正它们，它们就变得越糟。
				</div>
				<h5>牢固性(Immobility ):很难解开系统的纠结，使之成为一些可在其他系统中重用的组件。</h5>
				<div>
					设计中包含了对其他系统有用的部分，但是要把这些部分从系统中分离出来所需要的努力和风险是巨大的。这是一件令人遗憾的事，但却是非常常见的事情。
				</div>
				<h5>粘滞性(Viscosity )做正确的事情比做错误的事情要困难。</h5>
				<div>
					粘滞性有两种表现形式:软件的粘滞性和环境的粘滞性。<br>
					当面临一个改动时，开发人员常常发现会有多种改动的方法。其中，一些方法会保持设计;而另外一些会破坏设计(也就是生硬的手法)。当那些可以保持系统
					设计的方法比那些生硬手法更难应用时，就表明设计具有高的粘滞性。做错误的事情是容易的，但是做正确的事情却很难。我们希望在软件设计中，可以容易
					地进行那些保持设计的变动。<br>
					当开发环境迟钝、低效时，就会产生环境的粘滞性。例如，如果编译所花费的时间很长，那么开发人员就会被引诱去做不会导致大规模重编译的改动，即使那些
					改动不再保持设计。如果源代码控制系统需要几个小时去拆入(check in )仅仅几个文件，那么开发人员就会被引诱去做那些需要尽可能少拆入的改动，而不管
					改动是否会保持设计。<br>
					无论项目具有哪种粘滞性，都很难保持项目中的软件设计。我们希望创建易于保持设计的系统和项目环境。
				</div>
				<h5>不必要的复杂性(Needless Complexity ):设计中包含有不具任何直接好处的基础结构。</h5>
				<div>
					如果设计中包含有当前没有用的组成部分，它就含有不必要的复杂性。当开发人员预测需求的变化，并在软件中放置了处理那些潜在变化的代码时，常常会出
					现这种情况。起初，这样做看起来像是一件好事。毕竟，为将来的变化做准备会保持代码的灵活性，并且可以避免以后再进行痛苦的改动。<br>
				    糟糕的是，结果常常正好相反。为过多的可能性做准备，致使设计中含有绝不会用到的结构，从而变得混乱。一些准备也许会带来回报，但是更多的不会。期间
					，设计背负着这些不会用到的部分，使软件变得复杂，并且难以理解。
				</div>
				<h5>不必要的重复(Needless Repetition):设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统一。</h5>
				<div>
					剪切(cut)和粘贴(paste)也许是有用的文本编辑(text-editing)操作，但是它们却是灾难性的代码编辑(code-editing)操作。时常，软件系统都是构建于
					众多的重复代码片断之上。<br />
					当同样的代码以稍微不同的形式一再出现时，就表示开发人员忽视了抽象。对于他们来说，发现所有的重复并通过适当的抽象去消除它们的做法可能没有高的
					优先级别，但是这样做非常有助于使系统更加易于理解和维护。<br />
					当系统中有重复的代码时，对系统进行改动会变得困难。在一个重复的代码体中发现的错误必须要在每个重复体中一一修正。不过，由于每个重复体之间都有
					细微的差别，所以修正的方式也不总是相同的。
				</div>
				<h5>晦涩性(Opacity ):很难阅读、理解。没有很好地表现出意图。</h5>
				<div>
					晦涩性是指模块难以理解。代码可以用清晰、富有表现力的方式编写，或者可以用晦涩、费解的方式编写。代码随着时间而演化，往往会变得越来越晦涩。为
					了使代码的晦涩性保持最低，就需要持续地保持代码清晰并富有表现力。<br />
					当开发人员最初编写一个模块时，代码对于他们来说看起来也许是清晰的。这是由于他们使自己专注于代码的编写，并且他们对于代码非常的熟悉。在熟悉减
					退以后，他们或许会回过头来再去看那个模块，并想知道他们怎么会编写如此糟糕的代码。为了防止这种情况的发生，开发人员必须要站在代码阅读者的位置
					，共同努力对他们的代码进行重构，这样代码的阅读者就可以理解代码。他们的代码也需要被其他人评审。<br />
				</div>
			</div>
			<h4>7.2.1 什么激发了软件的腐化</h4>
			<div>
				在非敏捷环境中，由于需求没有按照初始设计预见的方式进行变化，从而导致了设计的退化。通常，改动都很急迫，并且进行改动的开发人员对于原始的设计思路并
				不熟悉。因而，虽然对设计的改动可以工作，但是它却以某种方式违反了原始的设计。随着改动的不断进行，这些违反渐渐地积累，设计开始出现臭味。<br />
				然而，我们不能因为设计的退化而责怪需求的变化。作为软件开发人员，我们对于需求变化有非常好的了解。事实上，我们中的大多数人都认识到需求是项目中最不
				稳定的要素。如果我们的设计由于持续、大量的需求变化而失败，那就表明我们的设计和实践本身是有缺陷的。我们必须要设法找到一种方法，使得设计对于这种变
				化具有弹性，并且应用一些实践来防止设计腐化。
			</div>
			<h4>7.2.2 敏捷团队不允许软件腐化</h4>
			<div>
				敏捷团队依靠变化来获取活力。团队几乎不进行预先(up-front)设计，因此，不需要一个成熟的初始设计。他们更愿意保持系统设计尽可能的干净、简单，并使用
				许多单元测试和验收测试作为支援。这保持了设计的灵活性、易于理解性。团队利用这种灵活性，持续地改进设计，以便于每次迭代结束所生成的系统都具有最适合
				于那次迭代中需求的设计。
			</div>
			
			<h3>7.3 </h3>
			<div>
				在变化面前，程序的设计退化的速度是非常快的。我们可以坐下来去指责变化。我们可以抱怨程序对于最初的要求是设计良好的，是因为后来对要求的改变导致了
				设计的退化。然而，这种抱怨忽视了软件开发中最重要的事实之一:需求总是在变化。<br>
				记住，在大多数软件项目中最不稳定的东西就是需求。需求处在一个持续变动的状态之中。这是我们作为开发人员必须得接受的事实!我们生存在一个需求不断变化
				的世界中，我们的工作是要保证我们的软件能够经受得住那些变化。如果我们软件的设计由于需求变化了而退化，那么我们就不是敏捷的。<br>
				在需求变化或要增加新的需求时，团队抓住这次机会去改进设计，以便设计对于将来的同类变化具有弹性，而不是设法去给设计打补丁。如果没有证据表明会出现
				某一类需求，我们是不需要为“未来可能出现”的需求做额外的保护。
			</div>
			<h4>7.3.2 敏捷开发人员如何知道要做什么</h4>
			<div>
				敏捷开发人员知道要做什么，是因为:
				<li>他们遵循敏捷实践去发现问题;</li>
				<li>他们应用设计原则去诊断问题;</li>
				<li>们应用适当的设计模式去解决问题。</li>
				软件开发的这三个方面间的相互作用就是设计。
			</div>
			
			<h3>7.4保持尽可能好的设计</h3>
			<div>
				敏捷开发人员致力于保持设计尽可能地适当、干净。这不是一个随便的或者暂时性的承诺。敏捷开发人员不是每几周才清洁他们的设计。而是每天、每小
				时、甚至每分钟都要保持软件尽可能地干净、简单并富有表现力。他们从来不说，“稍后我们会回来修正它。”他们决不让腐化出现。<br />
				敏捷开发人员对待软件设计的态度和外科医生对待消毒过程的态度是一样的。消毒过程使外科手术成为可能。没有它，被感染的风险之高是难以忍受的。
				敏捷开发人员对于他们的设计有同样的感觉。即使最小的腐化带来的风险也同样高到无法忍受。<br />
				设计必须要保持干净、简单，并且由于源代码是设计最重要的表示，所以它同样要保持干净。职业特性要求我们，作为软件开发人员，不能忍受代码腐化。
			</div>
			<h3>结论</h3>
			<div>
				那么，什么是敏捷设计呢?敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保
				持系统设计在任何时间都尽可能得简单、干净以及富有表现力。<br />
				敏捷开发人员不会对一个庞大的预先设计应用那些原则和模式。相反，这些原则和模式被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净。
			</div>
		</div>
		
		<h2>第8章 单一职责原则(SRP)</h2>
		<div>
			<h3>8.1单一职责原则(SRP)</h3>
			<div>
				就一个类而言，应该仅有一个引起它变化的原因。<br>
				为何要把这两个职责分离到单独的类中呢?因为每一个职责都是变化的一个轴线(an axis of change)。当需求变化时，该变化会反映为类的职责的变化。
				如果一个类承担了多于一个的职责，那么引起它变化的原因就会有多个。<br>
				如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的
				(fragile )设计，当变化发生时，设计会遭受到意想不到的破坏。
			</div>
			<h4>8.1.1 什么是职责</h4>
			<div>
				在SRP中，我们把职责定义为“变化的原因”( a reason for change )。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职
				责。有时，我们很难注意到这一点。我们习惯于以组的形式去考虑职责。<br>
				另一方面，如果应用程序的变化方式总是导致这两个职责同时变化，那么就不必分离它们。实际上，分离它们就会具有不必要的复杂性的臭味。<br>
				在此还有一个推论。变化的轴线仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者任何其他原则都是不明智的。
			</div>
			<h4>8.1.2 分离耦合的职责</h4>
			<div>
				常常会有一些和硬件或者操作系统的细节有关的原因，迫使我们把不愿耦合在一起的东西耦合在了一起。然而，对于应用的其余部分来说，通过分离它们
				的接口我们来解耦其概念。
			</div>
			<h4>8.2 结论</h4>
			<div>
				SRP是所有原则中最简单的之一，也是最难正确运用的之一。我们会自然地把职责结合在一起。软件设计真正要做的许多内容，就是发现职责并把那些职责
				相互分离。事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。
			</div>
		</div>
		
		<h2>第9章 开放一封闭原则(OCP)</h2>
		<div>
			<h3>9.1 开放一封闭原则(OCP )</h3>
			<div>
				软件实体(类、模块、函数等等)应该是可以扩展的，但是不可修改的。<br />
				如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。OCP建议我们应该对系统进行重构，这样以后对系
				统再进行那样的改动时，就不会导致更多的修改。如果正确地应用OCP，那么以后再进行同样的改动时，就只需要添加新的代码，而不必改动已经正常运行
				的代码。<br />
				也许，这看起来像是众所周知的可望而不可及的美好理想—然而，事实上却有一些相对简单并且有效的策略可以帮助接近这个理想。
			</div>
			<h2>9.2 描述</h2>
			<div>
				遵循开放一封闭原则设计出的模块具有两个主要的特征。它们是:<br />
				1、“对于扩展是开放的”(Open for extension ) 。<br />
				这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块的
				功能。
				2、“对于更改是封闭的”(Closed for modificaiton ) 。<br />
				对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者Java的.jar文件，都无需改动。<br />
				这两个特征好像是互相矛盾的。扩展模块行为的通常方式就是修改该模块的源代码。不允许修改的模块常常都被认为是具有固定的行为。<br />
				在不改动模块源代码的情况下去更改它的行为,关键是抽象！
			</div>
			<h3>9.3 关键是抽象</h3>
			<div>
				在C++、Java或者其他任何的OOPL中，可以创建出固定却能够描述一组任意个可能行为的抽象体。这个抽象体就是抽象基类。而这一组任意个可能的行为
				则表现为可能的派生类。<br />
				模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，所以它对于更改可以是关闭的。同时，通过从这个抽象体派生，也可以扩展此模块的行为。
			</div>
			<h3>9.3.5 预测变化和“贴切的”结构</h3>
			<div>
				一般而言，无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。没有对于所有的情况都贴切的模型。<br />
				既然不可能完全封闭，那么就必须有策略地对待这个问题。也就是说，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最
				有可能发生的变化种类，然后构造抽象来隔离那些变化。<br />
				这需要设计人员具备一些从经验中获得的预测能力。有经验的设计人员希望自己对用户和应用领域很了解，能够以此来判断各种变化的可能性。然后，他
				可以让设计对于最有可能发生的变化遵循OCP原则。<br />
				这一点不容易做到。因为它意味着要根据经验猜测那些应用程序在生长历程中有可能遭受的变化。如果开发人员猜测正确，他们就获得成功。如果他们猜
				测错误，他们会遭受失败。并且在大多数情况下，他们都会猜测错误。<br />
				同时，遵循OCP的代价也是昂贵的。创建正确的抽象是要花费开发时间和精力的。同时，那些抽象也增加了软件设计的复杂性。开发人员有能力处理的抽象
				的数量也是有限的。显然，我们希望把OCP的应用限定在可能会发生的变化上。<br />
				我们如何知道哪个变化有可能发生呢?我们进行适当的调查，提出正确的问题，并且使用我们的经验和一般常识。最终，我们会一直等到变化发生时才采取
				行动。
			</div>
			<h3>9.3.6 放置吊钩</h3>
			<div>
				我们怎样去隔离变化呢?在上个世纪，我们常常说的一句话是，我们会在我们认为可能发生变化的地方放置吊钩(hook)。我们觉得这样做会使软件灵活一些。<br />
				然而，我们放置的吊钩常常是错误的。更糟的是，即使不使用这些吊钩，也必须要去支持和维护它们，从而就具有了不必要的复杂性的臭味。这不是一件
				好事。我们不希望设计背着许多不必要的抽象。通常，我们更愿意一直等到确实需要那些抽象时再把它放置进去。
				<h5>1.只受一次愚弄</h5>
				<div>
					有句古老的谚语说:“愚弄我一次，应感羞愧的是你。再次愚弄我，应感羞愧的是我。”这也是一种有效的对待软件设计的态度。为了防止软件背着不必
					要的复杂性，我们会允许自己被愚弄一次。这意味着在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的
					同类变化。简而言之，我们愿意被第一颗子弹击中，然后我们会确保自己不再被同一只枪发射的其他任何子弹击中。
				</div>
				<h4>2.刺激变化</h4>
				<div>
					如果我们决定接受第一颗子弹，那么子弹到来的越早、越快就对我们越有利。我们希望在开发工作展开不久就知道可能发生的变化。查明可能发生的
					变化所等待的时间越长，要创建正确的抽象就越困难。<br />
					因此，我们需要去刺激变化。<br />
					<li>我们首先编写测试。测试描绘了系统的一种使用方法。通过首先编写测试，我们迫使系统成为可测试的。在一个具有可测试性的系统中发生变化
					时，我们可以坦然对之。因为我们己经构建了使系统可测试的抽象。并且通常这些抽象中的许多都会隔离以后发生的其他种类的变化。</li>
					<li>我们使用很短的迭代周期进行开发—一个周期为几天而不是几周。</li>
					<li>我们在加入基础结构前就开发特性，并且经常性地把那些特性展示给涉众。</li>
					<li>我们首先开发最重要的特性。</li>
					<li>尽早地、经常性地发布软件。尽可能快地、尽可能频繁地把软件展示给客户和使用人员。</li>
				</div>
			</div>
			<h3>9.3.7 使用抽象获得显式封闭</h3>
			<h3>9.3.8 使用“数据驱动”的方法获取封闭</h3>
			<h3>9.4 结论</h3>
			<div>
				在许多方面，OCP都是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处(也就是，灵活性、可重用性以及可维护性)。然而
				，并不是说只要使用一种面向对象语言就是遵循了这个原则。对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确的做法是，开发人
				员应该仅仅对程序中呈现出频繁变化的那些部分做出抽象。拒绝不成熟的抽象和抽象本身一样重要。
			</div>
		</div>
		
		
	</body>
</html>
