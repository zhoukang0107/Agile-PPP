<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>设计原则（下）</title>
	</head>
	<body>
		<h2>第十章 Liskow替换原则(LSP)</h2>
		<div>
			&nbsp;&nbsp;&nbsp;&nbsp;子类型必须能够替换掉他们的基类型。<br>
			这里需要如下替换性质：若对每个类型S的对象O1,都存在一个类型T的对象O2，使得在所有针对T编写的程序P中，用O1替换O2后，程序P行为功
			能不变，则S是T的子类型。<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LSP的重要性就不言而喻了。假设有一个函数f,它的参数为指向某个基类B的指针(( pointer)或者引用(reference )。
			同样假设有B的某个派生类D,如果把D的对象作为B类型传递给f,会导致f出现错误的行为。那么D就违反了LSP。显然，D对于f来说是脆弱的。<br>
			&nbsp;&nbsp;&nbsp;&nbsp;f的编写者会想去对D进行一些测试，以便于在把D的对象传递给f时，可以使f具有正确的行为。这个测试违反了OCP，
			因为此时f对于B的所有不同的派生类都不再是封闭的。这样的测试是一种代码的臭味，它是缺乏经验的开发人员(或者，更糟的，匆忙的开发人员)
			在违反了LSP时所产生的结果。
			<h3>1.1 有效性并非本质属性</h3>
			<div>
				LSP让我们得出一个非常重要的结论:一个模型，如果孤立地看，并不具有真正意义上的有效性。模型的有效性只能通过它的客户程序来表现。<br>
				在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。<br>
				有谁知道设计的使用者会做出什么样的合理假设呢?大多数这样的假设都很难预测。事实上，如果试图去预测所有这些假设，我们所得到的系
				统很可能会充满不必要的复杂性的臭味。因此，像所有其他原则一样，通常最好的方法是只预测那些最明显的对于LSP的违反情况而推迟所有
				其他的预测，直到出现相关的脆弱性的臭味时，才去处理它们。<br>
			</div>
			<h3>1.2 基于契约设计</h3>
			<div>
				&nbsp;&nbsp;&nbsp;&nbsp;许多开发人员可能会对“合理假设”行为方式的概念感到不安。怎样才能知道客户真正的要求呢?有一项技术可以使这些
				合理的假设明确化，从而支持了LSP。这项技术被称为基于契约设计( Design By Contract，简称DBC). BertrandMeyer对此进行过详细的介绍。
				使用DBC，类的编写者显式地规定针对该类的契约。客户代码的编写者可以通过该契约获悉可以依赖的行为方式。契约是通过为每个方法声明的前
				置条件(preconditions )和后置条件( postconditions)来指定的。要使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后
				置条件为真。<br>
				&nbsp;&nbsp;&nbsp;&nbsp;基于契约设计的弊端：有些没有理解这个约定重要性的开发人员，在应用程序的多处地方违反了这个约定。这就是使用
				约定方式的问题—要不断地跟每位开发人员解释。如果某位开发人员没有弄清楚或者不同意，就会违反这个约定。而一次违反就会致使整个结构的失败。
			</div>
			<div>
				如果一组类都支持一个公共的职责，那么它们应该从一个公共的超类(superclass)继承该职责。如果公共的超类还不存在，那么就创建一个，并把公共
				的职责放入其中。毕竟，这样一个类的有用性是确定无疑的一一你已经展示了一些类会继承这些职责。然而稍后对系统的扩展也许会加入一个新的子类，
				该子类很可能会以新的方式来支持同样的职责。此时，这个新创建的超类可能会是一个抽象类。
			</div>
			<h3>结论</h3>
			<div>
				OCP是OOD中很多说法的核心。如果这个原则应用得有效，应用程序就会具有更多的可维护性、可重用性以及健壮性。LSP是使OCP成为可能的主要原则之一。
				正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展。这种可替换性必须是开发人员可以隐式依赖的东西。因此，如果没有
				显式地强制基类类型的契约，那么代码就必须良好地并且明显地表达出这一点。<br>
				术语“IS-A”的含意过于宽泛以至于不能作为子类型的定义。子类型的正确定义是“可替换性的”，这里的可替换性可以通过显式或者隐式的契约来定义。
			</div>
		</div>
		
		<h2>第11章依赖倒置原则(PIP )</h2>
		<div>
			a.高层模块不应该依赖于低层模块。二者都应该依赖于抽象。<br />
			b.抽象不应该依赖于细节。细节应该依赖于抽象.<br />
			当高层模块依赖于低层模块时意味着什么。高层模块包含了一个应用程序中的重要的策略选择和业务模型。正是这些高层模块才使得其所在的应用程序区别于其他。
			然而，如果这些高层模块依赖于低层模块，那么对低层模块的改动就会直接影响到高层模块，从而迫使它们依次做出改动。<br>
			这种情形是非常荒谬的!本应该是高层的策略设置模块去影响低层的细节实现模块的。包含高层业务规则的模块应该优先并独立于包含实现细节的模块。无论如何高
			层模块都不应该依赖于低层模块。<br>
			此外，我们更希望能够重用的是高层的策略设置模块。我们己经非常擅长于通过子程序库的形式来重用低层模块。如果高层模块依赖于低层模块，那么在不同的上下
			文中重用高层模块就会变得非常困难。然而，如果高层模块独立于低层模块，那么高层模块就可以非常容易地被重用。该原则是框架(framework)设计的核心原则。
			<h3>11.1 倒置的接口所有权</h3>
			<div>
				这就是著名的Hollywood原则:"Don't call us, we'll call you."(不要调用我们，我们会调用你。)低层模块实现了在高层模块中声明并被高层模块调用的接口。
			</div>
			<h3>11.2 依赖于抽象</h3>
			<div>
				一个稍微简单但仍然非常有效的对于DIP的解释，是这样一个简单的启发式规则:“依赖于抽象。”这是一个简单的陈述，该启发式规则建议不应该依赖于具体类—也就
				是说，程序中所有的依赖关系都应该终止于抽象类或者接口。<br />
				根据这个启发式规则，可知:<br />
				<li>任何变量都不应该持有一个指向具体类的指针或者引用</li>
				<li>任何类都不应该从具体类派生</li>
				<li>任何方法都不应该覆写它的任何基类中的已经实现了的方法</li>
				当然，每个程序中都会有违反该启发规则的情况。有时必须要创建具体类的实例，而创建这些实例的模块将会依赖于它们。此外，该启发规则对于那些虽是具体但却
				稳定(nonvolatile)的类来说似乎不太合理。如果一个具体类不太会改变，并且也不会创建其他类似的派生类，那么依赖于它并不会造成损害。<br />
				比如，在大多数的系统中，描述字符串的类都是具体的。例如，在Java中，表示字符串的是具体类String。该类是稳定的，也就是说，它不太会改变。因此，直接依
				赖于它不会造成损害。<br />
				然而，我们在应用程序中所编写的大多数具体类都是不稳定的。我们不想直接依赖于这些不稳定的具体类。通过把它们隐藏在抽象接口的后面，可以隔离它们的不稳定性。<br />
				这不是一个完美的解决方案。常常，如果一个不稳定类的接口必须要变化时，这个变化一定会影响到表示该类的抽象接口。这种变化破坏了由抽象接口维系的隔离性。<br />
				由此可知，该启发规则对问题的考虑有点简单了。另一方面，如果看得更远一点，认为是由客户类来声明它们需要的服务接口，那么仅当客户需要时才会对接口进行改变。
				这样，改变实现抽象接口的类就不会影响到客户。<br />
			</div>
			<h3>结论</h3>
			<div>
				使用传统的过程化程序设计所创建出来的依赖关系结构，策略是依赖于细节的。这是糟糕的，因为这样会使策略受到细节改变的影响。面向对象的程序设计倒置了依赖关系
				结构，使得细节和策略都依赖于抽象，并且常常是客户拥有服务接口。<br />
				事实上，这种依赖关系的倒置正是好的面向对象设计的标志所在。使用何种语言来编写程序是无关紧要的。如果程序的依赖关系是倒置的，它就是面向对象的设计。如果程
				序的依赖关系不是倒置的，它就是过程化的设计。<br />
				依赖倒置原则是实现许多面向对象技术所宣称的好处的基本低层机制。它的正确应用对于创建可重用的框架来说是必须的。同时它对于构建在变化面前富有弹性的代码也是
				非常重要的。由于抽象和细节被彼此隔离，所以代码也非常容易维护。<br />
			</div>
		</div>
	
		<h2>第十二章 接口隔离原则(ISP )</h2>
		<div>
			不应该强迫客户依赖于它们不用的方法。<br />
			这个原则用来处理“胖(fat)”接口所具有的缺点。如果类的接口不是内聚的(cohesive)，就表示该类具有“胖”的接口。换句话说，类的“胖”接口可以分解成多组方法。每一组方法
			都服务于一组不同的客户程序。这样，一些客户程序可以使用一组成员函数，而其他客户程序可以使用其他组的成员函数。<br />
			ISP承认存在有一些对象，它们确实不需要内聚的接口;但是ISP建议客户程序不应该看到它们作为单一的类存在。相反，客户程序看到的应该是多个具有内聚接口的抽象基类。<br />
			如果强迫客户程序依赖于那些它们不使用的方法，那么这些客户程序就面临着由于这些未使用方法的改变所带来的变更。这无意中导致了所有客户程序之间的祸合。换种说法，如果
			一个客户程序依赖于一个含有它不使用的方法的类，但是其他客户程序却要使用该方法，那么当其他客户要求这个类改变时，就会影响到这个客户程序。我们希望尽可能地避免这种
			祸合，因此我们希望分离接<br />
			<h3>结论</h3>
			<div>
				胖类(fat class)会导致它们的客户程序之间产生不正常的并且有害的耦合关系。当一个客户程序要求该胖类进行一个改动时，会影响到所有其他的客户程序。因此，客户程序
				应该仅仅依赖于它们实际调用的方法。通过把胖类的接口分解为多个特定于客户程序的接口，可以实现这个目标。每个特定于客户程序的接口仅仅声明它的特定客户或者客户组
				调用的那些函数。接着，该胖类就可以继承所有特定于客户程序的接口，并实现它们。这就解除了客户程序和它们没有调用的方法间的依赖关系，并使客户程序之间互不依赖。

			</div>
		</div>
	</body>
</html>
